// win32 Visual C 2010 이상컴파일시 추가
// 프로그램 가장 첫 줄에 추가할 것
#define _CRT_SECURE_NO_WARNINGS
//-------------------------------------------

#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include <conio.h>

/* for oracle */
#include <sqlda.h>
#include <sqlca.h>
#include <sqlcpr.h>
/*------------*/

#define getch() _getch()

void DB_connect();
void M_select_tuple();
void M_update_tuple();
void rtrim();

void sql_error();

EXEC SQL BEGIN DECLARE SECTION;
	VARCHAR uid[80];
	VARCHAR pwd[20];
EXEC SQL END DECLARE SECTION;

char J_SOCIAL_NUM[100], J_NAME[14], J_FAM[13], J_SPOUSE_NUM[100] ;

void main()
{
	DB_connect();
	M_select_tuple();
	M_update_tuple();
	getch();
	EXEC SQL COMMIT WORK RELEASE ;
}
void DB_connect()
{
   strcpy((char *)uid.arr,"b20163374@//sedb.deu.ac.kr:1521/orcl");
   uid.len = (short) strlen((char *)uid.arr);
   strcpy((char *)pwd.arr,"20163374");
   pwd.len = (short) strlen((char *)pwd.arr);

   EXEC SQL CONNECT :uid IDENTIFIED BY :pwd;

	// connection이 실패했을경우의 처리부분

	if (sqlca.sqlcode != 0 && sqlca.sqlcode != -1405){ 
		printf("\7Cconnect error: %s", sqlca.sqlerrm.sqlerrmc);
		getch();
		exit(-1);
	}

    printf("Oracle Connect SUCCESS by %s\n", uid.arr);
}

void M_update_tuple() //혼인신고 업데이트
{

EXEC SQL BEGIN DECLARE SECTION;

   char dynstmtm_1[1000];

EXEC SQL END DECLARE SECTION;

   char  m_fam[13];
   char  m_spouse[100];
  
   EXEC SQL WHENEVER SQLERROR DO sql_error("\7ORACLE ERROR:\n");
   printf("<배우자의 주민등록번호를 입력하세요>\n");   

   printf("%s %s\n", J_FAM, J_SPOUSE_NUM);

   printf("부양가족:");
   gets(m_fam);
   if( m_fam[0]== '\0' ){
        printf("%s\n", J_FAM);
	strcpy(m_fam, J_FAM);
   }

   printf("배우자 주민등록번호:");
   gets(m_spouse);
   if( m_spouse[0]== '\0' ){
        printf("%s\n", J_SPOUSE_NUM);
	strcpy(m_spouse, J_SPOUSE_NUM);
   }


   sprintf(dynstmtm_1,"update jumin set  j_fam = '%s', j_spouse_num = '%s' where j_social_num = '%s'", m_fam, m_spouse, J_SOCIAL_NUM);
   
   EXEC SQL EXECUTE IMMEDIATE :dynstmtm_1 ;

   printf("신혼신고가 완료되었습니다. 결혼을 축하드립니다♡\n");
   EXEC SQL COMMIT WORK ; 

}


void M_select_tuple() //혼인신고 조회
{


EXEC SQL BEGIN DECLARE SECTION;
    varchar m_social[100];
    varchar m_name[14];
    varchar m_fam1[13];
    varchar m_spouse1[100];
    char dynstmtm_2[1000];
EXEC SQL END DECLARE SECTION;
    
    char m_social_temp[20];

     
    EXEC SQL WHENEVER SQLERROR DO sql_error("\7ORACLE ERROR:\n");
   
      
    printf("자신의 주민번호를 입력하세요:");
    fgets(m_social_temp, 20, stdin); 
    m_social_temp[strlen(m_social_temp)-1] = '\0' ;  

    sprintf(dynstmtm_2,"SELECT j_social_num, j_name, j_fam, j_spouse_num  FROM jumin where j_social_num = '%s'", m_social_temp) ;

    EXEC SQL PREPARE S FROM :dynstmtm_2 ;

    EXEC SQL DECLARE c_cursorm_1 CURSOR FOR S ; 

    EXEC SQL OPEN c_cursorm_1 ; 

  
    EXEC SQL WHENEVER NOT FOUND do break;
    for(;;)
    {
        EXEC SQL FETCH c_cursorm_1 INTO :m_social, :m_name, :m_fam1, :m_spouse1 ;

	    m_social.arr[m_social.len] = '\0';


	    m_name.arr[m_name.len] = '\0';
	    m_fam1.arr[m_fam1.len] = '\0';
	    m_spouse1.arr[m_spouse1.len] = '\0';
	    printf("\n<개인 정보>\n\n주민등록번호:%s\n\n이름:%s \n\n부양가족:%s\n\n배우자 주민등록번호: %s\n\n", m_social.arr, m_name.arr, m_fam1.arr, m_spouse1.arr);
    }
	
    	strcpy(J_SOCIAL_NUM, m_social.arr);
	strcpy(J_NAME, m_name.arr);
	strcpy(J_FAM, m_fam1.arr);
	strcpy(J_SPOUSE_NUM, m_spouse1.arr);
    printf("일치하는 정보 : %d건\n\n", sqlca.sqlerrd[2]);
    EXEC SQL CLOSE c_cursorm_1; 
   

}

/* --------------------------------------------------------------------------
void sql_error()

   errrpt prints the ORACLE error msg and number.
-------------------------------------------------------------------------- */
void sql_error(char *msg)
{
    char err_msg[128];
    size_t buf_len, msg_len;

    EXEC SQL WHENEVER SQLERROR CONTINUE;

    printf("\n%s\n", msg);
    buf_len = sizeof (err_msg);
    sqlglm(err_msg, &buf_len, &msg_len);
    printf("%.*s\n", msg_len, err_msg);

    getch();

    EXEC SQL ROLLBACK WORK ;
    //exit(EXIT_FAILURE);
}

void rtrim(char temp[])
{
	int i;

	i = strlen(temp)-1;
	
	while (temp[i] == ' ' && i > 0 ){
		i--;
        }
	temp[i+1]='\0';
}